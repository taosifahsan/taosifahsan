program decode
/******************************************************************************
 *  Name:    Taosif Ahsan
 *  NetID:   tahsan
 *  Precept: P13
 *
 *  Description: decodes the encoded parity bits and corrects the message
 *
 ******************************************************************************/
        // reading m1
10: 81FF   read R[1]                     
        // jumping to halt if m1=FFFF
11: 7F01   R[F] <- 0001                  
12: 1FF1   R[F] <- R[F] + R[1]           
13: CF52   if (R[F] == 0) goto 52               
        // reading    m2,m3,m4
14: 82FF   read R[2]                     
15: 83FF   read R[3]                     
16: 84FF   read R[4]                     
        // reading p1,p2,p3
17: 85FF   read R[5]                     
18: 86FF   read R[6]                     
19: 87FF   read R[7]                     
        // check parity bits
            // c1 = p1 ^ m1 ^ m2 ^ m4
1A: 4A51   R[A] <- R[5] ^ R[1]           
1B: 4AA2   R[A] <- R[A] ^ R[2]           
1C: 4AA4   R[A] <- R[A] ^ R[4]           
            // c2 = p2 ^ m1 ^ m3 ^ m4
1D: 4B61   R[B] <- R[6] ^ R[1]           
1E: 4BB3   R[B] <- R[B] ^ R[3]           
1F: 4BB4   R[B] <- R[B] ^ R[4]           
            // c3 = p3 ^ m2 ^ m3 ^ m4
20: 4C72   R[C] <- R[7] ^ R[2]           
21: 4CC3   R[C] <- R[C] ^ R[3]           
22: 4CC4   R[C] <- R[C] ^ R[4]           
 
        // flip bits if necessary
 
            //if (c1 + c2 + c3 == 3) m4 = 1 ^ m4
23: 1DAB   R[D] <- R[A] + R[B]           
24: 1DDC   R[D] <- R[D] + R[C]           
25: 7F03   R[F] <- 0003                  
26: 2DDF   R[D] <- R[D] - R[F]           
27: CD2A   if (R[D] == 0) goto 2A        
28: 7D00   R[D] <- 0000                  
29: CD2E   if (R[D] == 0) goto 2E        
2A: 7F01   R[F] <- 0001                  
2B: 44F4   R[4] <- R[F] ^ R[4]           
2C: 7F4C   R[F] <- 004C                  
2D: EF00   goto R[F]                     
            // else if(c1 + c2 == 2) m1 = 1 ^ m1
2E: 1DAB   R[D] <- R[A] + R[B]           
2F: 7F02   R[F] <- 0002                  
30: 2DDF   R[D] <- R[D] - R[F]           
31: CD34   if (R[D] == 0) goto 34        
32: 7D00   R[D] <- 0000                  
33: CD38   if (R[D] == 0) goto 38        
34: 7F01   R[F] <- 0001                  
35: 41F1   R[1] <- R[F] ^ R[1]           
36: 7F4C   R[F] <- 004C                  
37: EF00   goto R[F]                     
            // else if(c1 + c3 == 2) m2 = 1 ^ m2
38: 1DAC   R[D] <- R[A] + R[C]           
39: 7F02   R[F] <- 0002                  
3A: 2DDF   R[D] <- R[D] - R[F]           
3B: CD3E   if (R[D] == 0) goto 3E        
3C: 7D00   R[D] <- 0000                  
3D: CD42   if (R[D] == 0) goto 42        
3E: 7F01   R[F] <- 0001                  
3F: 42F2   R[2] <- R[F] ^ R[2]           
40: 7F4C   R[F] <- 004C                  
41: EF00   goto R[F]                     
            // else if(c2 + c3 == 2) m3 = 1 ^ m3
42: 1DBC   R[D] <- R[B] + R[C]           
43: 7F02   R[F] <- 0002                  
44: 2DDF   R[D] <- R[D] - R[F]           
45: CD48   if (R[D] == 0) goto 48        
46: 7D00   R[D] <- 0000                  
47: CD4C   if (R[D] == 0) goto 4C        
48: 7F01   R[F] <- 0001                  
49: 43F3   R[3] <- R[F] ^ R[3]           
4A: 7F4C   R[F] <- 004C                  
4B: EF00   goto R[F]                     
           // writing the corrected codes
4C: 91FF   write R[1]                    
4D: 92FF   write R[2]                    
4E: 93FF   write R[3]                    
4F: 94FF   write R[4]                    
           // loop
50: 7F10   R[F] <- 0010                  
51: EF00   goto R[F]                     
52: 0000   halt                          